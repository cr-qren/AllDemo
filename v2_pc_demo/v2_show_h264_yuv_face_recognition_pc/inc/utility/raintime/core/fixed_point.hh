/*!\copyright
 * Copyright (c) 2017 Corerain Technologies. All rights reserved.
 * No part of this document, either material or conceptual may be
 * copied or distributed, transmitted, transcribed, stored in a retrieval
 * system or translated into any human or computer language in
 * any form by any means, electronic, mechanical, manual
 * or otherwise, or disclosed to third parties without
 * the express written permission of Corerain Technologies.
 */

#ifndef RAINTIME_FIXED_POINT_HH__
#define RAINTIME_FIXED_POINT_HH__

// automatically generated by CMake
#include "fixed_point_conf.hh"

#include <glog/logging.h>
#include <stdint.h>
#include <unistd.h>
#include <cmath>
#include <iostream>
#include <limits>
#include <third_party/Eigen/Core>

using Eigen::NumTraits;

namespace raintime {

inline constexpr float PowerOfTwoByShift(const int &exp) {
  return (exp >= 0)
             ? (static_cast<float>(static_cast<int64_t>(1) << exp))
             : (1.0 / static_cast<float>(static_cast<int64_t>(1) << (-exp)));
}

/*!< Return the scaling factor of a fixed-point value */
inline constexpr float GetFixedPointScale(const int &num_fb) {
  return PowerOfTwoByShift(num_fb);
}

/*! \brief Get the maximum value in float that can be represented by
 * the FixedPoint<num_fb, num_ib, sign>.
 */
inline constexpr float GetMaxFixedPointValue(const int &num_fb,
                                             const int &num_bits,
                                             const bool &sign) {
  return sign
             ? ((PowerOfTwoByShift(num_bits - 1) - 1) /
                GetFixedPointScale(num_fb))
             : ((PowerOfTwoByShift(num_bits) - 1) / GetFixedPointScale(num_fb));
}

/*! \brief Get the minimum value in float that can be represented by
 * the FixedPoint<num_fb, num_ib, sign>.
 */
inline constexpr float GetMinFixedPointValue(const int &num_fb,
                                             const int &num_bits,
                                             const bool &sign) {
  return sign ? (-(PowerOfTwoByShift(num_bits - 1) - 1) /
                 GetFixedPointScale(num_fb))
              : 0.0f;
}

/*!< Clip the input value by the given range. */
inline float ClipByValue(const float &val, float min, float max) {
  float new_val = val;
  new_val = new_val < min ? min : new_val;
  new_val = new_val > max ? max : new_val;
  return new_val;
}

/*!< Round the given floating point to fixed-point through
 * the round-to-nearest method.
 */
inline float RoundToNearest(const float &x, const float &scale, float min_val,
                            float max_val, const bool &min_max_scaled = false,
                            const bool &scale_result = true) {
  float rounded_and_scaled = std::floor(x * scale + 0.5f);
  if (!min_max_scaled) {
    min_val *= scale;
    max_val *= scale;
  }
  float result = ClipByValue(rounded_and_scaled, min_val, max_val);
  return scale_result ? result / scale : result;
}

/*!< Round to nearest with values computed online */
inline float RoundToNearest(const float &x, const int &num_fb,
                            const int &num_bits, const bool &sign,
                            const bool &scale_result = true) {
  CHECK(!(!sign && x < 0))
      << "We cannot represent minus value with unsigned integer";

  float scale = GetFixedPointScale(num_fb);
  float min_val = GetMinFixedPointValue(num_fb, num_bits, sign);
  float max_val = GetMaxFixedPointValue(num_fb, num_bits, sign);

  return RoundToNearest(x, scale, min_val, max_val, false, scale_result);
}

/*! Convert fixed-point value back to floating-point */
template <typename ST = int32_t>
inline float FixedToFloat(ST val, const int &num_fb) {
  return static_cast<float>(val) / GetFixedPointScale(num_fb);
}

template <int NF, int NI, bool S>
struct FixedPointTraits {
  static const bool IsValid = false;
};

#define DOUBLE(x) DOUBLE_##x
#define DOUBLE_8 16
#define DOUBLE_16 32
#define DOUBLE_32 64
#define CAT2(x, y, z) x##y##z
#define CAT(x, y, z) CAT2(x, y, z)

#define INIT_FIXED_POINT_EIGEN(NF, NI, S)                                \
  namespace Eigen {                                                      \
  template <>                                                            \
  struct NumTraits<raintime::FixedPoint<NF, NI, S>> : NumTraits<float> { \
    typedef raintime::FixedPoint<NF, NI, S> Real;                        \
    typedef raintime::FixedPoint<NF, NI, S> Integer;                     \
    typedef raintime::FixedPoint<NF, NI, S> Nested;                      \
                                                                         \
    enum {                                                               \
      IsComplex = 0,                                                     \
      IsInteger = 0,                                                     \
      IsReal = 1,                                                        \
      IsSigned = S,                                                      \
      RequireInitialization = 1,                                         \
      ReadCost = 1,                                                      \
      AddCost = 1,                                                       \
      MulCost = 5,                                                       \
      DivCost = 5                                                        \
    };                                                                   \
    static inline raintime::FixedPoint<NF, NI, S> highest() {            \
      return raintime::FixedPoint<NF, NI, S>::max();                     \
    }                                                                    \
    static inline raintime::FixedPoint<NF, NI, S> lowest() {             \
      return raintime::FixedPoint<NF, NI, S>::min();                     \
    }                                                                    \
  };                                                                     \
                                                                         \
  namespace internal {                                                   \
  template <>                                                            \
  struct abs2_impl<raintime::FixedPoint<NF, NI, S>> {                    \
    EIGEN_DEVICE_FUNC static inline float run(                           \
        const raintime::FixedPoint<NF, NI, S> &x) {                      \
      return static_cast<float>(x * x);                                  \
    }                                                                    \
  };                                                                     \
  template <>                                                            \
  struct scalar_product_traits<raintime::FixedPoint<NF, NI, S>,          \
                               raintime::FixedPoint<NF, NI, S>> {        \
    enum { Defined = 1 };                                                \
    typedef raintime::FixedPoint<NF, NI, S> ReturnType;                  \
  };                                                                     \
                                                                         \
  inline const raintime::FixedPoint<NF, NI, S> conj(                     \
      const raintime::FixedPoint<NF, NI, S> &x) {                        \
    return x;                                                            \
  }                                                                      \
  inline const raintime::FixedPoint<NF, NI, S> real(                     \
      const raintime::FixedPoint<NF, NI, S> &x) {                        \
    return x;                                                            \
  }                                                                      \
  inline raintime::FixedPoint<NF, NI, S> imag(                           \
      const raintime::FixedPoint<NF, NI, S> &) {                         \
    return static_cast<raintime::FixedPoint<NF, NI, S>>(0.0f);           \
  }                                                                      \
  inline raintime::FixedPoint<NF, NI, S> abs(                            \
      const raintime::FixedPoint<NF, NI, S> &x) {                        \
    return std::fabs(static_cast<float>(x));                             \
  }                                                                      \
  inline raintime::FixedPoint<NF, NI, S> abs2(                           \
      const raintime::FixedPoint<NF, NI, S> &x) {                        \
    return x * x;                                                        \
  }                                                                      \
  }                                                                      \
  }

#define INIT_FIXED_POINT_TRAITS(nf, bw)              \
  namespace raintime {                               \
  template <>                                        \
  struct FixedPointTraits<nf, bw - nf - 1, true> {   \
    static const bool IsValid = true;                \
    typedef int##bw##_t StorageType;                 \
    typedef CAT(int, DOUBLE(bw), _t) TemporaryType;  \
  };                                                 \
  template <>                                        \
  struct FixedPointTraits<nf, bw - nf, false> {      \
    static const bool IsValid = true;                \
    typedef uint##bw##_t StorageType;                \
    typedef CAT(uint, DOUBLE(bw), _t) TemporaryType; \
  };                                                 \
  }                                                  \
  INIT_FIXED_POINT_EIGEN(nf, bw - nf - 1, true)      \
  INIT_FIXED_POINT_EIGEN(nf, bw - nf, false)

#define INIT_FIXED_POINT_TRAITS_8(nf) INIT_FIXED_POINT_TRAITS(nf, 8)
#define INIT_FIXED_POINT_TRAITS_16(nf) INIT_FIXED_POINT_TRAITS(nf, 16)
#define INIT_FIXED_POINT_TRAITS_32(nf) INIT_FIXED_POINT_TRAITS(nf, 32)

template <int NF, int NI, bool S>
class FixedPoint {
 public:
  // ST stands for storage type, TT stands for temporary type
  typedef typename FixedPointTraits<NF, NI, S>::StorageType ST;
  typedef typename FixedPointTraits<NF, NI, S>::TemporaryType TT;

  static constexpr int NB = S ? NF + NI + 1 : NF + NI;
  static constexpr float SCALE = GetFixedPointScale(NF);
  // min and max in float
  static constexpr float MIN_FLOAT = GetMinFixedPointValue(NF, NB, S);
  static constexpr float MAX_FLOAT = GetMaxFixedPointValue(NF, NB, S);
  // min and max in ST
  static constexpr ST MAX_FIXED = std::numeric_limits<ST>::max();
  static constexpr ST MIN_FIXED = std::numeric_limits<ST>::min();

  static constexpr TT ROUND_VALUE = (1 << (NF - 1));

  FixedPoint() {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Initialise with 0";
#endif
    val_ = 0;
  }
  FixedPoint(const int val) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Initialise with int " << val;
#endif
    val_ = static_cast<ST>(RoundToNearest(static_cast<float>(val), false));
  }
  FixedPoint(const unsigned int val) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Initialise with unsigned int " << val;
#endif
    val_ = static_cast<ST>(RoundToNearest(static_cast<float>(val), false));
  }
  FixedPoint(const float val) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Initialise with float " << val;
#endif
    val_ = static_cast<ST>(RoundToNearest(val, false));
  }
  FixedPoint(const double val) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Initialise with double " << val;
#endif
    val_ = static_cast<ST>(RoundToNearest(static_cast<float>(val), false));
  }

  static FixedPoint<NF, NI, S> MakeByRawValue(ST val) {
    FixedPoint<NF, NI, S> inst;
    inst.set_raw_value(val);
    return inst;
  }

  static inline float RoundToNearest(const float val,
                                     bool scale_result = true) {
    // wrap the function external to this class
    // we round with scaled min-max values and scale the returned value by
    // default.
    return ::raintime::RoundToNearest(val, scale(), min_in_float_scaled(),
                                      max_in_float_scaled(), true,
                                      scale_result);
  }

  static float ToFloat(const ST val) { return static_cast<float>(val) / SCALE; }

  static inline ST Saturate(const TT &x) {
    if (x > max())
      return max();
    else if (x < min())
      return min();
    else
      return static_cast<ST>(x);
  }

  FixedPoint<NF, NI, S> &operator=(const float val) {
    val_ = static_cast<ST>(RoundToNearest(val, false));
    return *this;
  }

  FixedPoint<NF, NI, S> &operator=(ST val) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Assign " << this->val() << " (" << static_cast<float>(*this)
              << ") with " << val;
#endif
    val_ = val;
    return *this;
  }

  FixedPoint<NF, NI, S> &operator=(const FixedPoint<NF, NI, S> &fp2) {
#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Assign " << val() << " (" << static_cast<float>(*this)
              << ") with " << fp2.val() << " (" << static_cast<float>(fp2)
              << ")";
#endif
    this->val_ = fp2.raw_value();
    return *this;
  }

  operator float() const { return ToFloat(val_); }
  operator ST() const { return val_; }

  ST raw_value() const { return val_; }
  void set_raw_value(ST val) { val_ = val; }

#ifdef ALLOW_ASSIGN_DIFF_FIXED_POINT
  template <int NF2, int NI2, bool S2>
  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> &operator=(
      const FixedPoint<NF2, NI2, S2> &fp2) {
    *this = static_cast<float>(fp2);
    return *this;
  }
#endif

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator*(
      const FixedPoint<NF, NI, S> &fp) const {
    TT tmp = static_cast<TT>(val()) * static_cast<TT>(fp.val());
    tmp += ROUND_VALUE;

    auto result = FixedPoint<NF, NI, S>::MakeByRawValue(Saturate(tmp >> NF));

#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Multiply " << val() << " (" << static_cast<float>(*this)
              << ") with " << fp.val() << " (" << static_cast<float>(fp)
              << ")  got " << result.val() << " (" << static_cast<float>(result)
              << ")";
#endif

    return result;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator*=(
      const FixedPoint<NF, NI, S> &fp) {
    TT tmp = static_cast<TT>(val()) * static_cast<TT>(fp.val());
    tmp += ROUND_VALUE;
    val_ = Saturate(tmp >> NF);
    return *this;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator*(const float &fp) const {
    float tmp = static_cast<float>(val()) * fp;
    return FixedPoint<NF, NI, S>(tmp);
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator*=(const float &fp) {
    float tmp = static_cast<float>(val()) * fp;
    val_ = static_cast<ST>(tmp);
    return *this;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator+(
      const FixedPoint<NF, NI, S> &fp) const {
    auto result = FixedPoint<NF, NI, S>::MakeByRawValue(
        Saturate(static_cast<TT>(val()) + static_cast<TT>(fp.val())));

#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Add " << val() << " (" << static_cast<float>(*this)
              << ") with " << fp.val() << " (" << static_cast<float>(fp)
              << ")  got " << result.val() << " (" << static_cast<float>(result)
              << ")";
#endif
    return result;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator+=(
      const FixedPoint<NF, NI, S> &fp) {
    auto result = Saturate(static_cast<TT>(val()) + static_cast<TT>(fp.val()));

#ifdef TRACE_FIXED_POINT_ARITH
    LOG(INFO) << "Add Assign " << val() << " (" << static_cast<float>(*this)
              << ") with " << fp.val() << " (" << static_cast<float>(fp)
              << ")  got " << result;
#endif
    val_ = result;
    return *this;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator-(
      const FixedPoint<NF, NI, S> &fp) const {
    return FixedPoint<NF, NI, S>::MakeByRawValue(
        Saturate(static_cast<TT>(val()) - static_cast<TT>(fp.val())));
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator-=(
      const FixedPoint<NF, NI, S> &fp) {
    val_ = Saturate(static_cast<TT>(val()) - static_cast<TT>(fp.val()));
    return *this;
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator/(
      const FixedPoint<NF, NI, S> &fp) const {
    TT temp = static_cast<TT>(val()) << NF;
    if ((temp >= static_cast<TT>(0.0f) &&
         static_cast<TT>(fp.val()) >= static_cast<TT>(0.0f)) ||
        (temp < static_cast<TT>(0.0f) && static_cast<TT>(fp.val()) < 0)) {
      temp += static_cast<TT>(fp.val()) / static_cast<TT>(2.0f);
    } else {
      temp -= static_cast<TT>(fp.val()) / static_cast<TT>(2.0f);
    }
    return FixedPoint<NF, NI, S>::MakeByRawValue(
        Saturate(static_cast<TT>(temp) / static_cast<TT>(fp.val())));
  }

  EIGEN_STRONG_INLINE FixedPoint<NF, NI, S> operator/=(
      const FixedPoint<NF, NI, S> &fp) const {
    TT temp = static_cast<TT>(val()) << NF;
    if ((temp >= static_cast<TT>(0.0f) &&
         static_cast<TT>(fp.val()) >= static_cast<TT>(0.0f)) ||
        (temp < static_cast<TT>(0.0f) && static_cast<TT>(fp.val()) < 0)) {
      temp += static_cast<TT>(fp.val()) / static_cast<TT>(2.0f);
    } else {
      temp -= static_cast<TT>(fp.val()) / static_cast<TT>(2.0f);
    }
    val_ = Saturate(static_cast<TT>(temp) / static_cast<TT>(fp.val()));
    return *this;
  }

  friend std::ostream &operator<<(std::ostream &os,
                                  const FixedPoint<NF, NI, S> &fp) {
    os << static_cast<float>(fp);
    return os;
  }

  EIGEN_STRONG_INLINE bool operator<(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) < static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator>(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) > static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator==(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) == static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator!=(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) != static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator<=(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) <= static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator>=(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) >= static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator&&(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) && static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator||(const FixedPoint<NF, NI, S> &fp) const {
    return static_cast<float>(this->val_) || static_cast<float>(fp.val());
  }
  EIGEN_STRONG_INLINE bool operator&(const FixedPoint<NF, NI, S> &fp) const {
    return this->val_ & fp.val();
  }
  EIGEN_STRONG_INLINE bool operator|(const FixedPoint<NF, NI, S> &fp) const {
    return this->val_ | fp.val();
  }

  inline ST val() const { return val_; }

  static inline int num_bits() { return NB; }
  static inline float scale() { return SCALE; }
  static inline ST max() { return MAX_FIXED; }
  static inline ST min() { return MIN_FIXED; }
  static inline float max_in_float() { return MAX_FLOAT; }
  static inline float min_in_float() { return MIN_FLOAT; }
  static inline float max_in_float_scaled() { return max_in_float() * scale(); }
  static inline float min_in_float_scaled() { return min_in_float() * scale(); }

 private:
  ST val_;
};
}  // namespace raintime

INIT_FIXED_POINT_TRAITS_8(1);
INIT_FIXED_POINT_TRAITS_8(2);
INIT_FIXED_POINT_TRAITS_8(3);
INIT_FIXED_POINT_TRAITS_8(4);
INIT_FIXED_POINT_TRAITS_8(5);
INIT_FIXED_POINT_TRAITS_8(6);
INIT_FIXED_POINT_TRAITS_8(7);

INIT_FIXED_POINT_TRAITS_16(1);
INIT_FIXED_POINT_TRAITS_16(2);
INIT_FIXED_POINT_TRAITS_16(3);
INIT_FIXED_POINT_TRAITS_16(4);
INIT_FIXED_POINT_TRAITS_16(5);
INIT_FIXED_POINT_TRAITS_16(6);
INIT_FIXED_POINT_TRAITS_16(7);
INIT_FIXED_POINT_TRAITS_16(8);
INIT_FIXED_POINT_TRAITS_16(9);
INIT_FIXED_POINT_TRAITS_16(10);
INIT_FIXED_POINT_TRAITS_16(11);
INIT_FIXED_POINT_TRAITS_16(12);
INIT_FIXED_POINT_TRAITS_16(13);
INIT_FIXED_POINT_TRAITS_16(14);
INIT_FIXED_POINT_TRAITS_16(15);

INIT_FIXED_POINT_TRAITS_32(1);
INIT_FIXED_POINT_TRAITS_32(2);
INIT_FIXED_POINT_TRAITS_32(3);
INIT_FIXED_POINT_TRAITS_32(4);
INIT_FIXED_POINT_TRAITS_32(5);
INIT_FIXED_POINT_TRAITS_32(6);
INIT_FIXED_POINT_TRAITS_32(7);
INIT_FIXED_POINT_TRAITS_32(8);
INIT_FIXED_POINT_TRAITS_32(9);
INIT_FIXED_POINT_TRAITS_32(10);
INIT_FIXED_POINT_TRAITS_32(11);
INIT_FIXED_POINT_TRAITS_32(12);
INIT_FIXED_POINT_TRAITS_32(13);
INIT_FIXED_POINT_TRAITS_32(14);
INIT_FIXED_POINT_TRAITS_32(15);
INIT_FIXED_POINT_TRAITS_32(16);
INIT_FIXED_POINT_TRAITS_32(17);
INIT_FIXED_POINT_TRAITS_32(18);
INIT_FIXED_POINT_TRAITS_32(19);
INIT_FIXED_POINT_TRAITS_32(20);
INIT_FIXED_POINT_TRAITS_32(21);
INIT_FIXED_POINT_TRAITS_32(22);
INIT_FIXED_POINT_TRAITS_32(23);
INIT_FIXED_POINT_TRAITS_32(24);
INIT_FIXED_POINT_TRAITS_32(25);
INIT_FIXED_POINT_TRAITS_32(26);
INIT_FIXED_POINT_TRAITS_32(27);
INIT_FIXED_POINT_TRAITS_32(28);
INIT_FIXED_POINT_TRAITS_32(29);
INIT_FIXED_POINT_TRAITS_32(30);
INIT_FIXED_POINT_TRAITS_32(31);

#endif
