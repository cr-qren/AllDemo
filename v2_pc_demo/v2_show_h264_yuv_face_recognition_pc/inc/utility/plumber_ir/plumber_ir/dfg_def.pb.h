// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plumber_ir/dfg_def.proto

#ifndef PROTOBUF_plumber_5fir_2fdfg_5fdef_2eproto__INCLUDED
#define PROTOBUF_plumber_5fir_2fdfg_5fdef_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "plumber_ir/type_def.pb.h"
#include "plumber_ir/op_param_def.pb.h"
// @@protoc_insertion_point(includes)

namespace plumber_ir {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_plumber_5fir_2fdfg_5fdef_2eproto();
void protobuf_AssignDesc_plumber_5fir_2fdfg_5fdef_2eproto();
void protobuf_ShutdownFile_plumber_5fir_2fdfg_5fdef_2eproto();

class DFGNodeDef;
class DFGDef;

enum DFGNodeDef_Device {
  DFGNodeDef_Device_CPU = 0,
  DFGNodeDef_Device_FPGA = 1
};
bool DFGNodeDef_Device_IsValid(int value);
const DFGNodeDef_Device DFGNodeDef_Device_Device_MIN = DFGNodeDef_Device_CPU;
const DFGNodeDef_Device DFGNodeDef_Device_Device_MAX = DFGNodeDef_Device_FPGA;
const int DFGNodeDef_Device_Device_ARRAYSIZE = DFGNodeDef_Device_Device_MAX + 1;

const ::google::protobuf::EnumDescriptor* DFGNodeDef_Device_descriptor();
inline const ::std::string& DFGNodeDef_Device_Name(DFGNodeDef_Device value) {
  return ::google::protobuf::internal::NameOfEnum(
    DFGNodeDef_Device_descriptor(), value);
}
inline bool DFGNodeDef_Device_Parse(
    const ::std::string& name, DFGNodeDef_Device* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DFGNodeDef_Device>(
    DFGNodeDef_Device_descriptor(), name, value);
}
// ===================================================================

class DFGNodeDef : public ::google::protobuf::Message {
 public:
  DFGNodeDef();
  virtual ~DFGNodeDef();

  DFGNodeDef(const DFGNodeDef& from);

  inline DFGNodeDef& operator=(const DFGNodeDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DFGNodeDef& default_instance();

  enum OpParamCase {
    kInputOpParam = 100,
    kConv2DOpParam = 101,
    kMaxPool2DOpParam = 102,
    kConv2DOpTransposeParam = 103,
    kSoftmaxOpParam = 104,
    kBatchnormOpParam = 105,
    kFullyconnectedOpParam = 106,
    kDropoutOpParam = 107,
    kFlattenOpParam = 108,
    kReshapeOpParam = 109,
    kArgmaxOpParam = 110,
    kLrnOpParam = 111,
    OP_PARAM_NOT_SET = 0,
  };

  enum TypeParamCase {
    kFloatParam = 200,
    kFixedParam = 201,
    kIntParam = 202,
    TYPE_PARAM_NOT_SET = 0,
  };

  void Swap(DFGNodeDef* other);

  // implements Message ----------------------------------------------

  DFGNodeDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DFGNodeDef& from);
  void MergeFrom(const DFGNodeDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DFGNodeDef_Device Device;
  static const Device CPU = DFGNodeDef_Device_CPU;
  static const Device FPGA = DFGNodeDef_Device_FPGA;
  static inline bool Device_IsValid(int value) {
    return DFGNodeDef_Device_IsValid(value);
  }
  static const Device Device_MIN =
    DFGNodeDef_Device_Device_MIN;
  static const Device Device_MAX =
    DFGNodeDef_Device_Device_MAX;
  static const int Device_ARRAYSIZE =
    DFGNodeDef_Device_Device_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Device_descriptor() {
    return DFGNodeDef_Device_descriptor();
  }
  static inline const ::std::string& Device_Name(Device value) {
    return DFGNodeDef_Device_Name(value);
  }
  static inline bool Device_Parse(const ::std::string& name,
      Device* value) {
    return DFGNodeDef_Device_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string input = 2;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::std::string& input(int index) const;
  inline ::std::string* mutable_input(int index);
  inline void set_input(int index, const ::std::string& value);
  inline void set_input(int index, const char* value);
  inline void set_input(int index, const char* value, size_t size);
  inline ::std::string* add_input();
  inline void add_input(const ::std::string& value);
  inline void add_input(const char* value);
  inline void add_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // required string op = 3;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 3;
  inline const ::std::string& op() const;
  inline void set_op(const ::std::string& value);
  inline void set_op(const char* value);
  inline void set_op(const char* value, size_t size);
  inline ::std::string* mutable_op();
  inline ::std::string* release_op();
  inline void set_allocated_op(::std::string* op);

  // optional .plumber_ir.DFGNodeDef.Device device = 4 [default = CPU];
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 4;
  inline ::plumber_ir::DFGNodeDef_Device device() const;
  inline void set_device(::plumber_ir::DFGNodeDef_Device value);

  // optional .plumber_ir.DataType type = 5 [default = T_FLOAT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::plumber_ir::DataType type() const;
  inline void set_type(::plumber_ir::DataType value);

  // repeated .plumber_ir.Shape input_shape = 6;
  inline int input_shape_size() const;
  inline void clear_input_shape();
  static const int kInputShapeFieldNumber = 6;
  inline const ::plumber_ir::Shape& input_shape(int index) const;
  inline ::plumber_ir::Shape* mutable_input_shape(int index);
  inline ::plumber_ir::Shape* add_input_shape();
  inline const ::google::protobuf::RepeatedPtrField< ::plumber_ir::Shape >&
      input_shape() const;
  inline ::google::protobuf::RepeatedPtrField< ::plumber_ir::Shape >*
      mutable_input_shape();

  // optional .plumber_ir.InputOpParamDef input_op_param = 100;
  inline bool has_input_op_param() const;
  inline void clear_input_op_param();
  static const int kInputOpParamFieldNumber = 100;
  inline const ::plumber_ir::InputOpParamDef& input_op_param() const;
  inline ::plumber_ir::InputOpParamDef* mutable_input_op_param();
  inline ::plumber_ir::InputOpParamDef* release_input_op_param();
  inline void set_allocated_input_op_param(::plumber_ir::InputOpParamDef* input_op_param);

  // optional .plumber_ir.Conv2DOpParamDef conv2d_op_param = 101;
  inline bool has_conv2d_op_param() const;
  inline void clear_conv2d_op_param();
  static const int kConv2DOpParamFieldNumber = 101;
  inline const ::plumber_ir::Conv2DOpParamDef& conv2d_op_param() const;
  inline ::plumber_ir::Conv2DOpParamDef* mutable_conv2d_op_param();
  inline ::plumber_ir::Conv2DOpParamDef* release_conv2d_op_param();
  inline void set_allocated_conv2d_op_param(::plumber_ir::Conv2DOpParamDef* conv2d_op_param);

  // optional .plumber_ir.MaxPool2DOpParamDef max_pool2d_op_param = 102;
  inline bool has_max_pool2d_op_param() const;
  inline void clear_max_pool2d_op_param();
  static const int kMaxPool2DOpParamFieldNumber = 102;
  inline const ::plumber_ir::MaxPool2DOpParamDef& max_pool2d_op_param() const;
  inline ::plumber_ir::MaxPool2DOpParamDef* mutable_max_pool2d_op_param();
  inline ::plumber_ir::MaxPool2DOpParamDef* release_max_pool2d_op_param();
  inline void set_allocated_max_pool2d_op_param(::plumber_ir::MaxPool2DOpParamDef* max_pool2d_op_param);

  // optional .plumber_ir.Conv2DTransposeOpParamDef conv2d_op_transpose_param = 103;
  inline bool has_conv2d_op_transpose_param() const;
  inline void clear_conv2d_op_transpose_param();
  static const int kConv2DOpTransposeParamFieldNumber = 103;
  inline const ::plumber_ir::Conv2DTransposeOpParamDef& conv2d_op_transpose_param() const;
  inline ::plumber_ir::Conv2DTransposeOpParamDef* mutable_conv2d_op_transpose_param();
  inline ::plumber_ir::Conv2DTransposeOpParamDef* release_conv2d_op_transpose_param();
  inline void set_allocated_conv2d_op_transpose_param(::plumber_ir::Conv2DTransposeOpParamDef* conv2d_op_transpose_param);

  // optional .plumber_ir.SoftmaxOpParamDef softmax_op_param = 104;
  inline bool has_softmax_op_param() const;
  inline void clear_softmax_op_param();
  static const int kSoftmaxOpParamFieldNumber = 104;
  inline const ::plumber_ir::SoftmaxOpParamDef& softmax_op_param() const;
  inline ::plumber_ir::SoftmaxOpParamDef* mutable_softmax_op_param();
  inline ::plumber_ir::SoftmaxOpParamDef* release_softmax_op_param();
  inline void set_allocated_softmax_op_param(::plumber_ir::SoftmaxOpParamDef* softmax_op_param);

  // optional .plumber_ir.BatchNormOpParamDef batchnorm_op_param = 105;
  inline bool has_batchnorm_op_param() const;
  inline void clear_batchnorm_op_param();
  static const int kBatchnormOpParamFieldNumber = 105;
  inline const ::plumber_ir::BatchNormOpParamDef& batchnorm_op_param() const;
  inline ::plumber_ir::BatchNormOpParamDef* mutable_batchnorm_op_param();
  inline ::plumber_ir::BatchNormOpParamDef* release_batchnorm_op_param();
  inline void set_allocated_batchnorm_op_param(::plumber_ir::BatchNormOpParamDef* batchnorm_op_param);

  // optional .plumber_ir.FullyConnectedOpParamDef fullyconnected_op_param = 106;
  inline bool has_fullyconnected_op_param() const;
  inline void clear_fullyconnected_op_param();
  static const int kFullyconnectedOpParamFieldNumber = 106;
  inline const ::plumber_ir::FullyConnectedOpParamDef& fullyconnected_op_param() const;
  inline ::plumber_ir::FullyConnectedOpParamDef* mutable_fullyconnected_op_param();
  inline ::plumber_ir::FullyConnectedOpParamDef* release_fullyconnected_op_param();
  inline void set_allocated_fullyconnected_op_param(::plumber_ir::FullyConnectedOpParamDef* fullyconnected_op_param);

  // optional .plumber_ir.DropOutOpParamDef dropout_op_param = 107;
  inline bool has_dropout_op_param() const;
  inline void clear_dropout_op_param();
  static const int kDropoutOpParamFieldNumber = 107;
  inline const ::plumber_ir::DropOutOpParamDef& dropout_op_param() const;
  inline ::plumber_ir::DropOutOpParamDef* mutable_dropout_op_param();
  inline ::plumber_ir::DropOutOpParamDef* release_dropout_op_param();
  inline void set_allocated_dropout_op_param(::plumber_ir::DropOutOpParamDef* dropout_op_param);

  // optional .plumber_ir.FlattenOpParamDef flatten_op_param = 108;
  inline bool has_flatten_op_param() const;
  inline void clear_flatten_op_param();
  static const int kFlattenOpParamFieldNumber = 108;
  inline const ::plumber_ir::FlattenOpParamDef& flatten_op_param() const;
  inline ::plumber_ir::FlattenOpParamDef* mutable_flatten_op_param();
  inline ::plumber_ir::FlattenOpParamDef* release_flatten_op_param();
  inline void set_allocated_flatten_op_param(::plumber_ir::FlattenOpParamDef* flatten_op_param);

  // optional .plumber_ir.ReshapeOpParamDef reshape_op_param = 109;
  inline bool has_reshape_op_param() const;
  inline void clear_reshape_op_param();
  static const int kReshapeOpParamFieldNumber = 109;
  inline const ::plumber_ir::ReshapeOpParamDef& reshape_op_param() const;
  inline ::plumber_ir::ReshapeOpParamDef* mutable_reshape_op_param();
  inline ::plumber_ir::ReshapeOpParamDef* release_reshape_op_param();
  inline void set_allocated_reshape_op_param(::plumber_ir::ReshapeOpParamDef* reshape_op_param);

  // optional .plumber_ir.ArgMaxOpParamDef argmax_op_param = 110;
  inline bool has_argmax_op_param() const;
  inline void clear_argmax_op_param();
  static const int kArgmaxOpParamFieldNumber = 110;
  inline const ::plumber_ir::ArgMaxOpParamDef& argmax_op_param() const;
  inline ::plumber_ir::ArgMaxOpParamDef* mutable_argmax_op_param();
  inline ::plumber_ir::ArgMaxOpParamDef* release_argmax_op_param();
  inline void set_allocated_argmax_op_param(::plumber_ir::ArgMaxOpParamDef* argmax_op_param);

  // optional .plumber_ir.LrnOpParamDef lrn_op_param = 111;
  inline bool has_lrn_op_param() const;
  inline void clear_lrn_op_param();
  static const int kLrnOpParamFieldNumber = 111;
  inline const ::plumber_ir::LrnOpParamDef& lrn_op_param() const;
  inline ::plumber_ir::LrnOpParamDef* mutable_lrn_op_param();
  inline ::plumber_ir::LrnOpParamDef* release_lrn_op_param();
  inline void set_allocated_lrn_op_param(::plumber_ir::LrnOpParamDef* lrn_op_param);

  // optional .plumber_ir.FloatParamDef float_param = 200;
  inline bool has_float_param() const;
  inline void clear_float_param();
  static const int kFloatParamFieldNumber = 200;
  inline const ::plumber_ir::FloatParamDef& float_param() const;
  inline ::plumber_ir::FloatParamDef* mutable_float_param();
  inline ::plumber_ir::FloatParamDef* release_float_param();
  inline void set_allocated_float_param(::plumber_ir::FloatParamDef* float_param);

  // optional .plumber_ir.FixedParamDef fixed_param = 201;
  inline bool has_fixed_param() const;
  inline void clear_fixed_param();
  static const int kFixedParamFieldNumber = 201;
  inline const ::plumber_ir::FixedParamDef& fixed_param() const;
  inline ::plumber_ir::FixedParamDef* mutable_fixed_param();
  inline ::plumber_ir::FixedParamDef* release_fixed_param();
  inline void set_allocated_fixed_param(::plumber_ir::FixedParamDef* fixed_param);

  // optional .plumber_ir.IntParamDef int_param = 202;
  inline bool has_int_param() const;
  inline void clear_int_param();
  static const int kIntParamFieldNumber = 202;
  inline const ::plumber_ir::IntParamDef& int_param() const;
  inline ::plumber_ir::IntParamDef* mutable_int_param();
  inline ::plumber_ir::IntParamDef* release_int_param();
  inline void set_allocated_int_param(::plumber_ir::IntParamDef* int_param);

  inline OpParamCase op_param_case() const;
  inline TypeParamCase type_param_case() const;
  // @@protoc_insertion_point(class_scope:plumber_ir.DFGNodeDef)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_input_op_param();
  inline void set_has_conv2d_op_param();
  inline void set_has_max_pool2d_op_param();
  inline void set_has_conv2d_op_transpose_param();
  inline void set_has_softmax_op_param();
  inline void set_has_batchnorm_op_param();
  inline void set_has_fullyconnected_op_param();
  inline void set_has_dropout_op_param();
  inline void set_has_flatten_op_param();
  inline void set_has_reshape_op_param();
  inline void set_has_argmax_op_param();
  inline void set_has_lrn_op_param();
  inline void set_has_float_param();
  inline void set_has_fixed_param();
  inline void set_has_int_param();

  inline bool has_op_param();
  void clear_op_param();
  inline void clear_has_op_param();

  inline bool has_type_param();
  void clear_type_param();
  inline void clear_has_type_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::std::string* op_;
  int device_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::plumber_ir::Shape > input_shape_;
  union OpParamUnion {
    ::plumber_ir::InputOpParamDef* input_op_param_;
    ::plumber_ir::Conv2DOpParamDef* conv2d_op_param_;
    ::plumber_ir::MaxPool2DOpParamDef* max_pool2d_op_param_;
    ::plumber_ir::Conv2DTransposeOpParamDef* conv2d_op_transpose_param_;
    ::plumber_ir::SoftmaxOpParamDef* softmax_op_param_;
    ::plumber_ir::BatchNormOpParamDef* batchnorm_op_param_;
    ::plumber_ir::FullyConnectedOpParamDef* fullyconnected_op_param_;
    ::plumber_ir::DropOutOpParamDef* dropout_op_param_;
    ::plumber_ir::FlattenOpParamDef* flatten_op_param_;
    ::plumber_ir::ReshapeOpParamDef* reshape_op_param_;
    ::plumber_ir::ArgMaxOpParamDef* argmax_op_param_;
    ::plumber_ir::LrnOpParamDef* lrn_op_param_;
  } op_param_;
  union TypeParamUnion {
    ::plumber_ir::FloatParamDef* float_param_;
    ::plumber_ir::FixedParamDef* fixed_param_;
    ::plumber_ir::IntParamDef* int_param_;
  } type_param_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend void  protobuf_AddDesc_plumber_5fir_2fdfg_5fdef_2eproto();
  friend void protobuf_AssignDesc_plumber_5fir_2fdfg_5fdef_2eproto();
  friend void protobuf_ShutdownFile_plumber_5fir_2fdfg_5fdef_2eproto();

  void InitAsDefaultInstance();
  static DFGNodeDef* default_instance_;
};
// -------------------------------------------------------------------

class DFGDef : public ::google::protobuf::Message {
 public:
  DFGDef();
  virtual ~DFGDef();

  DFGDef(const DFGDef& from);

  inline DFGDef& operator=(const DFGDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DFGDef& default_instance();

  void Swap(DFGDef* other);

  // implements Message ----------------------------------------------

  DFGDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DFGDef& from);
  void MergeFrom(const DFGDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .plumber_ir.DFGNodeDef node = 2;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::plumber_ir::DFGNodeDef& node(int index) const;
  inline ::plumber_ir::DFGNodeDef* mutable_node(int index);
  inline ::plumber_ir::DFGNodeDef* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::plumber_ir::DFGNodeDef >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::plumber_ir::DFGNodeDef >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:plumber_ir.DFGDef)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::plumber_ir::DFGNodeDef > node_;
  friend void  protobuf_AddDesc_plumber_5fir_2fdfg_5fdef_2eproto();
  friend void protobuf_AssignDesc_plumber_5fir_2fdfg_5fdef_2eproto();
  friend void protobuf_ShutdownFile_plumber_5fir_2fdfg_5fdef_2eproto();

  void InitAsDefaultInstance();
  static DFGDef* default_instance_;
};
// ===================================================================


// ===================================================================

// DFGNodeDef

// required string name = 1;
inline bool DFGNodeDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DFGNodeDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DFGNodeDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DFGNodeDef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DFGNodeDef::name() const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.name)
  return *name_;
}
inline void DFGNodeDef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:plumber_ir.DFGNodeDef.name)
}
inline void DFGNodeDef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:plumber_ir.DFGNodeDef.name)
}
inline void DFGNodeDef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:plumber_ir.DFGNodeDef.name)
}
inline ::std::string* DFGNodeDef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGNodeDef.name)
  return name_;
}
inline ::std::string* DFGNodeDef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DFGNodeDef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:plumber_ir.DFGNodeDef.name)
}

// repeated string input = 2;
inline int DFGNodeDef::input_size() const {
  return input_.size();
}
inline void DFGNodeDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& DFGNodeDef::input(int index) const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.input)
  return input_.Get(index);
}
inline ::std::string* DFGNodeDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGNodeDef.input)
  return input_.Mutable(index);
}
inline void DFGNodeDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:plumber_ir.DFGNodeDef.input)
  input_.Mutable(index)->assign(value);
}
inline void DFGNodeDef::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:plumber_ir.DFGNodeDef.input)
}
inline void DFGNodeDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:plumber_ir.DFGNodeDef.input)
}
inline ::std::string* DFGNodeDef::add_input() {
  return input_.Add();
}
inline void DFGNodeDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:plumber_ir.DFGNodeDef.input)
}
inline void DFGNodeDef::add_input(const char* value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:plumber_ir.DFGNodeDef.input)
}
inline void DFGNodeDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:plumber_ir.DFGNodeDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DFGNodeDef::input() const {
  // @@protoc_insertion_point(field_list:plumber_ir.DFGNodeDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DFGNodeDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:plumber_ir.DFGNodeDef.input)
  return &input_;
}

// required string op = 3;
inline bool DFGNodeDef::has_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DFGNodeDef::set_has_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DFGNodeDef::clear_has_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DFGNodeDef::clear_op() {
  if (op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_->clear();
  }
  clear_has_op();
}
inline const ::std::string& DFGNodeDef::op() const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.op)
  return *op_;
}
inline void DFGNodeDef::set_op(const ::std::string& value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(value);
  // @@protoc_insertion_point(field_set:plumber_ir.DFGNodeDef.op)
}
inline void DFGNodeDef::set_op(const char* value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(value);
  // @@protoc_insertion_point(field_set_char:plumber_ir.DFGNodeDef.op)
}
inline void DFGNodeDef::set_op(const char* value, size_t size) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:plumber_ir.DFGNodeDef.op)
}
inline ::std::string* DFGNodeDef::mutable_op() {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGNodeDef.op)
  return op_;
}
inline ::std::string* DFGNodeDef::release_op() {
  clear_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = op_;
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DFGNodeDef::set_allocated_op(::std::string* op) {
  if (op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete op_;
  }
  if (op) {
    set_has_op();
    op_ = op;
  } else {
    clear_has_op();
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:plumber_ir.DFGNodeDef.op)
}

// optional .plumber_ir.DFGNodeDef.Device device = 4 [default = CPU];
inline bool DFGNodeDef::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DFGNodeDef::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DFGNodeDef::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DFGNodeDef::clear_device() {
  device_ = 0;
  clear_has_device();
}
inline ::plumber_ir::DFGNodeDef_Device DFGNodeDef::device() const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.device)
  return static_cast< ::plumber_ir::DFGNodeDef_Device >(device_);
}
inline void DFGNodeDef::set_device(::plumber_ir::DFGNodeDef_Device value) {
  assert(::plumber_ir::DFGNodeDef_Device_IsValid(value));
  set_has_device();
  device_ = value;
  // @@protoc_insertion_point(field_set:plumber_ir.DFGNodeDef.device)
}

// optional .plumber_ir.DataType type = 5 [default = T_FLOAT];
inline bool DFGNodeDef::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DFGNodeDef::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DFGNodeDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DFGNodeDef::clear_type() {
  type_ = 6;
  clear_has_type();
}
inline ::plumber_ir::DataType DFGNodeDef::type() const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.type)
  return static_cast< ::plumber_ir::DataType >(type_);
}
inline void DFGNodeDef::set_type(::plumber_ir::DataType value) {
  assert(::plumber_ir::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:plumber_ir.DFGNodeDef.type)
}

// repeated .plumber_ir.Shape input_shape = 6;
inline int DFGNodeDef::input_shape_size() const {
  return input_shape_.size();
}
inline void DFGNodeDef::clear_input_shape() {
  input_shape_.Clear();
}
inline const ::plumber_ir::Shape& DFGNodeDef::input_shape(int index) const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGNodeDef.input_shape)
  return input_shape_.Get(index);
}
inline ::plumber_ir::Shape* DFGNodeDef::mutable_input_shape(int index) {
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGNodeDef.input_shape)
  return input_shape_.Mutable(index);
}
inline ::plumber_ir::Shape* DFGNodeDef::add_input_shape() {
  // @@protoc_insertion_point(field_add:plumber_ir.DFGNodeDef.input_shape)
  return input_shape_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::plumber_ir::Shape >&
DFGNodeDef::input_shape() const {
  // @@protoc_insertion_point(field_list:plumber_ir.DFGNodeDef.input_shape)
  return input_shape_;
}
inline ::google::protobuf::RepeatedPtrField< ::plumber_ir::Shape >*
DFGNodeDef::mutable_input_shape() {
  // @@protoc_insertion_point(field_mutable_list:plumber_ir.DFGNodeDef.input_shape)
  return &input_shape_;
}

// optional .plumber_ir.InputOpParamDef input_op_param = 100;
inline bool DFGNodeDef::has_input_op_param() const {
  return op_param_case() == kInputOpParam;
}
inline void DFGNodeDef::set_has_input_op_param() {
  _oneof_case_[0] = kInputOpParam;
}
inline void DFGNodeDef::clear_input_op_param() {
  if (has_input_op_param()) {
    delete op_param_.input_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::InputOpParamDef& DFGNodeDef::input_op_param() const {
  return has_input_op_param() ? *op_param_.input_op_param_
                      : ::plumber_ir::InputOpParamDef::default_instance();
}
inline ::plumber_ir::InputOpParamDef* DFGNodeDef::mutable_input_op_param() {
  if (!has_input_op_param()) {
    clear_op_param();
    set_has_input_op_param();
    op_param_.input_op_param_ = new ::plumber_ir::InputOpParamDef;
  }
  return op_param_.input_op_param_;
}
inline ::plumber_ir::InputOpParamDef* DFGNodeDef::release_input_op_param() {
  if (has_input_op_param()) {
    clear_has_op_param();
    ::plumber_ir::InputOpParamDef* temp = op_param_.input_op_param_;
    op_param_.input_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_input_op_param(::plumber_ir::InputOpParamDef* input_op_param) {
  clear_op_param();
  if (input_op_param) {
    set_has_input_op_param();
    op_param_.input_op_param_ = input_op_param;
  }
}

// optional .plumber_ir.Conv2DOpParamDef conv2d_op_param = 101;
inline bool DFGNodeDef::has_conv2d_op_param() const {
  return op_param_case() == kConv2DOpParam;
}
inline void DFGNodeDef::set_has_conv2d_op_param() {
  _oneof_case_[0] = kConv2DOpParam;
}
inline void DFGNodeDef::clear_conv2d_op_param() {
  if (has_conv2d_op_param()) {
    delete op_param_.conv2d_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::Conv2DOpParamDef& DFGNodeDef::conv2d_op_param() const {
  return has_conv2d_op_param() ? *op_param_.conv2d_op_param_
                      : ::plumber_ir::Conv2DOpParamDef::default_instance();
}
inline ::plumber_ir::Conv2DOpParamDef* DFGNodeDef::mutable_conv2d_op_param() {
  if (!has_conv2d_op_param()) {
    clear_op_param();
    set_has_conv2d_op_param();
    op_param_.conv2d_op_param_ = new ::plumber_ir::Conv2DOpParamDef;
  }
  return op_param_.conv2d_op_param_;
}
inline ::plumber_ir::Conv2DOpParamDef* DFGNodeDef::release_conv2d_op_param() {
  if (has_conv2d_op_param()) {
    clear_has_op_param();
    ::plumber_ir::Conv2DOpParamDef* temp = op_param_.conv2d_op_param_;
    op_param_.conv2d_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_conv2d_op_param(::plumber_ir::Conv2DOpParamDef* conv2d_op_param) {
  clear_op_param();
  if (conv2d_op_param) {
    set_has_conv2d_op_param();
    op_param_.conv2d_op_param_ = conv2d_op_param;
  }
}

// optional .plumber_ir.MaxPool2DOpParamDef max_pool2d_op_param = 102;
inline bool DFGNodeDef::has_max_pool2d_op_param() const {
  return op_param_case() == kMaxPool2DOpParam;
}
inline void DFGNodeDef::set_has_max_pool2d_op_param() {
  _oneof_case_[0] = kMaxPool2DOpParam;
}
inline void DFGNodeDef::clear_max_pool2d_op_param() {
  if (has_max_pool2d_op_param()) {
    delete op_param_.max_pool2d_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::MaxPool2DOpParamDef& DFGNodeDef::max_pool2d_op_param() const {
  return has_max_pool2d_op_param() ? *op_param_.max_pool2d_op_param_
                      : ::plumber_ir::MaxPool2DOpParamDef::default_instance();
}
inline ::plumber_ir::MaxPool2DOpParamDef* DFGNodeDef::mutable_max_pool2d_op_param() {
  if (!has_max_pool2d_op_param()) {
    clear_op_param();
    set_has_max_pool2d_op_param();
    op_param_.max_pool2d_op_param_ = new ::plumber_ir::MaxPool2DOpParamDef;
  }
  return op_param_.max_pool2d_op_param_;
}
inline ::plumber_ir::MaxPool2DOpParamDef* DFGNodeDef::release_max_pool2d_op_param() {
  if (has_max_pool2d_op_param()) {
    clear_has_op_param();
    ::plumber_ir::MaxPool2DOpParamDef* temp = op_param_.max_pool2d_op_param_;
    op_param_.max_pool2d_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_max_pool2d_op_param(::plumber_ir::MaxPool2DOpParamDef* max_pool2d_op_param) {
  clear_op_param();
  if (max_pool2d_op_param) {
    set_has_max_pool2d_op_param();
    op_param_.max_pool2d_op_param_ = max_pool2d_op_param;
  }
}

// optional .plumber_ir.Conv2DTransposeOpParamDef conv2d_op_transpose_param = 103;
inline bool DFGNodeDef::has_conv2d_op_transpose_param() const {
  return op_param_case() == kConv2DOpTransposeParam;
}
inline void DFGNodeDef::set_has_conv2d_op_transpose_param() {
  _oneof_case_[0] = kConv2DOpTransposeParam;
}
inline void DFGNodeDef::clear_conv2d_op_transpose_param() {
  if (has_conv2d_op_transpose_param()) {
    delete op_param_.conv2d_op_transpose_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::Conv2DTransposeOpParamDef& DFGNodeDef::conv2d_op_transpose_param() const {
  return has_conv2d_op_transpose_param() ? *op_param_.conv2d_op_transpose_param_
                      : ::plumber_ir::Conv2DTransposeOpParamDef::default_instance();
}
inline ::plumber_ir::Conv2DTransposeOpParamDef* DFGNodeDef::mutable_conv2d_op_transpose_param() {
  if (!has_conv2d_op_transpose_param()) {
    clear_op_param();
    set_has_conv2d_op_transpose_param();
    op_param_.conv2d_op_transpose_param_ = new ::plumber_ir::Conv2DTransposeOpParamDef;
  }
  return op_param_.conv2d_op_transpose_param_;
}
inline ::plumber_ir::Conv2DTransposeOpParamDef* DFGNodeDef::release_conv2d_op_transpose_param() {
  if (has_conv2d_op_transpose_param()) {
    clear_has_op_param();
    ::plumber_ir::Conv2DTransposeOpParamDef* temp = op_param_.conv2d_op_transpose_param_;
    op_param_.conv2d_op_transpose_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_conv2d_op_transpose_param(::plumber_ir::Conv2DTransposeOpParamDef* conv2d_op_transpose_param) {
  clear_op_param();
  if (conv2d_op_transpose_param) {
    set_has_conv2d_op_transpose_param();
    op_param_.conv2d_op_transpose_param_ = conv2d_op_transpose_param;
  }
}

// optional .plumber_ir.SoftmaxOpParamDef softmax_op_param = 104;
inline bool DFGNodeDef::has_softmax_op_param() const {
  return op_param_case() == kSoftmaxOpParam;
}
inline void DFGNodeDef::set_has_softmax_op_param() {
  _oneof_case_[0] = kSoftmaxOpParam;
}
inline void DFGNodeDef::clear_softmax_op_param() {
  if (has_softmax_op_param()) {
    delete op_param_.softmax_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::SoftmaxOpParamDef& DFGNodeDef::softmax_op_param() const {
  return has_softmax_op_param() ? *op_param_.softmax_op_param_
                      : ::plumber_ir::SoftmaxOpParamDef::default_instance();
}
inline ::plumber_ir::SoftmaxOpParamDef* DFGNodeDef::mutable_softmax_op_param() {
  if (!has_softmax_op_param()) {
    clear_op_param();
    set_has_softmax_op_param();
    op_param_.softmax_op_param_ = new ::plumber_ir::SoftmaxOpParamDef;
  }
  return op_param_.softmax_op_param_;
}
inline ::plumber_ir::SoftmaxOpParamDef* DFGNodeDef::release_softmax_op_param() {
  if (has_softmax_op_param()) {
    clear_has_op_param();
    ::plumber_ir::SoftmaxOpParamDef* temp = op_param_.softmax_op_param_;
    op_param_.softmax_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_softmax_op_param(::plumber_ir::SoftmaxOpParamDef* softmax_op_param) {
  clear_op_param();
  if (softmax_op_param) {
    set_has_softmax_op_param();
    op_param_.softmax_op_param_ = softmax_op_param;
  }
}

// optional .plumber_ir.BatchNormOpParamDef batchnorm_op_param = 105;
inline bool DFGNodeDef::has_batchnorm_op_param() const {
  return op_param_case() == kBatchnormOpParam;
}
inline void DFGNodeDef::set_has_batchnorm_op_param() {
  _oneof_case_[0] = kBatchnormOpParam;
}
inline void DFGNodeDef::clear_batchnorm_op_param() {
  if (has_batchnorm_op_param()) {
    delete op_param_.batchnorm_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::BatchNormOpParamDef& DFGNodeDef::batchnorm_op_param() const {
  return has_batchnorm_op_param() ? *op_param_.batchnorm_op_param_
                      : ::plumber_ir::BatchNormOpParamDef::default_instance();
}
inline ::plumber_ir::BatchNormOpParamDef* DFGNodeDef::mutable_batchnorm_op_param() {
  if (!has_batchnorm_op_param()) {
    clear_op_param();
    set_has_batchnorm_op_param();
    op_param_.batchnorm_op_param_ = new ::plumber_ir::BatchNormOpParamDef;
  }
  return op_param_.batchnorm_op_param_;
}
inline ::plumber_ir::BatchNormOpParamDef* DFGNodeDef::release_batchnorm_op_param() {
  if (has_batchnorm_op_param()) {
    clear_has_op_param();
    ::plumber_ir::BatchNormOpParamDef* temp = op_param_.batchnorm_op_param_;
    op_param_.batchnorm_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_batchnorm_op_param(::plumber_ir::BatchNormOpParamDef* batchnorm_op_param) {
  clear_op_param();
  if (batchnorm_op_param) {
    set_has_batchnorm_op_param();
    op_param_.batchnorm_op_param_ = batchnorm_op_param;
  }
}

// optional .plumber_ir.FullyConnectedOpParamDef fullyconnected_op_param = 106;
inline bool DFGNodeDef::has_fullyconnected_op_param() const {
  return op_param_case() == kFullyconnectedOpParam;
}
inline void DFGNodeDef::set_has_fullyconnected_op_param() {
  _oneof_case_[0] = kFullyconnectedOpParam;
}
inline void DFGNodeDef::clear_fullyconnected_op_param() {
  if (has_fullyconnected_op_param()) {
    delete op_param_.fullyconnected_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::FullyConnectedOpParamDef& DFGNodeDef::fullyconnected_op_param() const {
  return has_fullyconnected_op_param() ? *op_param_.fullyconnected_op_param_
                      : ::plumber_ir::FullyConnectedOpParamDef::default_instance();
}
inline ::plumber_ir::FullyConnectedOpParamDef* DFGNodeDef::mutable_fullyconnected_op_param() {
  if (!has_fullyconnected_op_param()) {
    clear_op_param();
    set_has_fullyconnected_op_param();
    op_param_.fullyconnected_op_param_ = new ::plumber_ir::FullyConnectedOpParamDef;
  }
  return op_param_.fullyconnected_op_param_;
}
inline ::plumber_ir::FullyConnectedOpParamDef* DFGNodeDef::release_fullyconnected_op_param() {
  if (has_fullyconnected_op_param()) {
    clear_has_op_param();
    ::plumber_ir::FullyConnectedOpParamDef* temp = op_param_.fullyconnected_op_param_;
    op_param_.fullyconnected_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_fullyconnected_op_param(::plumber_ir::FullyConnectedOpParamDef* fullyconnected_op_param) {
  clear_op_param();
  if (fullyconnected_op_param) {
    set_has_fullyconnected_op_param();
    op_param_.fullyconnected_op_param_ = fullyconnected_op_param;
  }
}

// optional .plumber_ir.DropOutOpParamDef dropout_op_param = 107;
inline bool DFGNodeDef::has_dropout_op_param() const {
  return op_param_case() == kDropoutOpParam;
}
inline void DFGNodeDef::set_has_dropout_op_param() {
  _oneof_case_[0] = kDropoutOpParam;
}
inline void DFGNodeDef::clear_dropout_op_param() {
  if (has_dropout_op_param()) {
    delete op_param_.dropout_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::DropOutOpParamDef& DFGNodeDef::dropout_op_param() const {
  return has_dropout_op_param() ? *op_param_.dropout_op_param_
                      : ::plumber_ir::DropOutOpParamDef::default_instance();
}
inline ::plumber_ir::DropOutOpParamDef* DFGNodeDef::mutable_dropout_op_param() {
  if (!has_dropout_op_param()) {
    clear_op_param();
    set_has_dropout_op_param();
    op_param_.dropout_op_param_ = new ::plumber_ir::DropOutOpParamDef;
  }
  return op_param_.dropout_op_param_;
}
inline ::plumber_ir::DropOutOpParamDef* DFGNodeDef::release_dropout_op_param() {
  if (has_dropout_op_param()) {
    clear_has_op_param();
    ::plumber_ir::DropOutOpParamDef* temp = op_param_.dropout_op_param_;
    op_param_.dropout_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_dropout_op_param(::plumber_ir::DropOutOpParamDef* dropout_op_param) {
  clear_op_param();
  if (dropout_op_param) {
    set_has_dropout_op_param();
    op_param_.dropout_op_param_ = dropout_op_param;
  }
}

// optional .plumber_ir.FlattenOpParamDef flatten_op_param = 108;
inline bool DFGNodeDef::has_flatten_op_param() const {
  return op_param_case() == kFlattenOpParam;
}
inline void DFGNodeDef::set_has_flatten_op_param() {
  _oneof_case_[0] = kFlattenOpParam;
}
inline void DFGNodeDef::clear_flatten_op_param() {
  if (has_flatten_op_param()) {
    delete op_param_.flatten_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::FlattenOpParamDef& DFGNodeDef::flatten_op_param() const {
  return has_flatten_op_param() ? *op_param_.flatten_op_param_
                      : ::plumber_ir::FlattenOpParamDef::default_instance();
}
inline ::plumber_ir::FlattenOpParamDef* DFGNodeDef::mutable_flatten_op_param() {
  if (!has_flatten_op_param()) {
    clear_op_param();
    set_has_flatten_op_param();
    op_param_.flatten_op_param_ = new ::plumber_ir::FlattenOpParamDef;
  }
  return op_param_.flatten_op_param_;
}
inline ::plumber_ir::FlattenOpParamDef* DFGNodeDef::release_flatten_op_param() {
  if (has_flatten_op_param()) {
    clear_has_op_param();
    ::plumber_ir::FlattenOpParamDef* temp = op_param_.flatten_op_param_;
    op_param_.flatten_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_flatten_op_param(::plumber_ir::FlattenOpParamDef* flatten_op_param) {
  clear_op_param();
  if (flatten_op_param) {
    set_has_flatten_op_param();
    op_param_.flatten_op_param_ = flatten_op_param;
  }
}

// optional .plumber_ir.ReshapeOpParamDef reshape_op_param = 109;
inline bool DFGNodeDef::has_reshape_op_param() const {
  return op_param_case() == kReshapeOpParam;
}
inline void DFGNodeDef::set_has_reshape_op_param() {
  _oneof_case_[0] = kReshapeOpParam;
}
inline void DFGNodeDef::clear_reshape_op_param() {
  if (has_reshape_op_param()) {
    delete op_param_.reshape_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::ReshapeOpParamDef& DFGNodeDef::reshape_op_param() const {
  return has_reshape_op_param() ? *op_param_.reshape_op_param_
                      : ::plumber_ir::ReshapeOpParamDef::default_instance();
}
inline ::plumber_ir::ReshapeOpParamDef* DFGNodeDef::mutable_reshape_op_param() {
  if (!has_reshape_op_param()) {
    clear_op_param();
    set_has_reshape_op_param();
    op_param_.reshape_op_param_ = new ::plumber_ir::ReshapeOpParamDef;
  }
  return op_param_.reshape_op_param_;
}
inline ::plumber_ir::ReshapeOpParamDef* DFGNodeDef::release_reshape_op_param() {
  if (has_reshape_op_param()) {
    clear_has_op_param();
    ::plumber_ir::ReshapeOpParamDef* temp = op_param_.reshape_op_param_;
    op_param_.reshape_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_reshape_op_param(::plumber_ir::ReshapeOpParamDef* reshape_op_param) {
  clear_op_param();
  if (reshape_op_param) {
    set_has_reshape_op_param();
    op_param_.reshape_op_param_ = reshape_op_param;
  }
}

// optional .plumber_ir.ArgMaxOpParamDef argmax_op_param = 110;
inline bool DFGNodeDef::has_argmax_op_param() const {
  return op_param_case() == kArgmaxOpParam;
}
inline void DFGNodeDef::set_has_argmax_op_param() {
  _oneof_case_[0] = kArgmaxOpParam;
}
inline void DFGNodeDef::clear_argmax_op_param() {
  if (has_argmax_op_param()) {
    delete op_param_.argmax_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::ArgMaxOpParamDef& DFGNodeDef::argmax_op_param() const {
  return has_argmax_op_param() ? *op_param_.argmax_op_param_
                      : ::plumber_ir::ArgMaxOpParamDef::default_instance();
}
inline ::plumber_ir::ArgMaxOpParamDef* DFGNodeDef::mutable_argmax_op_param() {
  if (!has_argmax_op_param()) {
    clear_op_param();
    set_has_argmax_op_param();
    op_param_.argmax_op_param_ = new ::plumber_ir::ArgMaxOpParamDef;
  }
  return op_param_.argmax_op_param_;
}
inline ::plumber_ir::ArgMaxOpParamDef* DFGNodeDef::release_argmax_op_param() {
  if (has_argmax_op_param()) {
    clear_has_op_param();
    ::plumber_ir::ArgMaxOpParamDef* temp = op_param_.argmax_op_param_;
    op_param_.argmax_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_argmax_op_param(::plumber_ir::ArgMaxOpParamDef* argmax_op_param) {
  clear_op_param();
  if (argmax_op_param) {
    set_has_argmax_op_param();
    op_param_.argmax_op_param_ = argmax_op_param;
  }
}

// optional .plumber_ir.LrnOpParamDef lrn_op_param = 111;
inline bool DFGNodeDef::has_lrn_op_param() const {
  return op_param_case() == kLrnOpParam;
}
inline void DFGNodeDef::set_has_lrn_op_param() {
  _oneof_case_[0] = kLrnOpParam;
}
inline void DFGNodeDef::clear_lrn_op_param() {
  if (has_lrn_op_param()) {
    delete op_param_.lrn_op_param_;
    clear_has_op_param();
  }
}
inline const ::plumber_ir::LrnOpParamDef& DFGNodeDef::lrn_op_param() const {
  return has_lrn_op_param() ? *op_param_.lrn_op_param_
                      : ::plumber_ir::LrnOpParamDef::default_instance();
}
inline ::plumber_ir::LrnOpParamDef* DFGNodeDef::mutable_lrn_op_param() {
  if (!has_lrn_op_param()) {
    clear_op_param();
    set_has_lrn_op_param();
    op_param_.lrn_op_param_ = new ::plumber_ir::LrnOpParamDef;
  }
  return op_param_.lrn_op_param_;
}
inline ::plumber_ir::LrnOpParamDef* DFGNodeDef::release_lrn_op_param() {
  if (has_lrn_op_param()) {
    clear_has_op_param();
    ::plumber_ir::LrnOpParamDef* temp = op_param_.lrn_op_param_;
    op_param_.lrn_op_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_lrn_op_param(::plumber_ir::LrnOpParamDef* lrn_op_param) {
  clear_op_param();
  if (lrn_op_param) {
    set_has_lrn_op_param();
    op_param_.lrn_op_param_ = lrn_op_param;
  }
}

// optional .plumber_ir.FloatParamDef float_param = 200;
inline bool DFGNodeDef::has_float_param() const {
  return type_param_case() == kFloatParam;
}
inline void DFGNodeDef::set_has_float_param() {
  _oneof_case_[1] = kFloatParam;
}
inline void DFGNodeDef::clear_float_param() {
  if (has_float_param()) {
    delete type_param_.float_param_;
    clear_has_type_param();
  }
}
inline const ::plumber_ir::FloatParamDef& DFGNodeDef::float_param() const {
  return has_float_param() ? *type_param_.float_param_
                      : ::plumber_ir::FloatParamDef::default_instance();
}
inline ::plumber_ir::FloatParamDef* DFGNodeDef::mutable_float_param() {
  if (!has_float_param()) {
    clear_type_param();
    set_has_float_param();
    type_param_.float_param_ = new ::plumber_ir::FloatParamDef;
  }
  return type_param_.float_param_;
}
inline ::plumber_ir::FloatParamDef* DFGNodeDef::release_float_param() {
  if (has_float_param()) {
    clear_has_type_param();
    ::plumber_ir::FloatParamDef* temp = type_param_.float_param_;
    type_param_.float_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_float_param(::plumber_ir::FloatParamDef* float_param) {
  clear_type_param();
  if (float_param) {
    set_has_float_param();
    type_param_.float_param_ = float_param;
  }
}

// optional .plumber_ir.FixedParamDef fixed_param = 201;
inline bool DFGNodeDef::has_fixed_param() const {
  return type_param_case() == kFixedParam;
}
inline void DFGNodeDef::set_has_fixed_param() {
  _oneof_case_[1] = kFixedParam;
}
inline void DFGNodeDef::clear_fixed_param() {
  if (has_fixed_param()) {
    delete type_param_.fixed_param_;
    clear_has_type_param();
  }
}
inline const ::plumber_ir::FixedParamDef& DFGNodeDef::fixed_param() const {
  return has_fixed_param() ? *type_param_.fixed_param_
                      : ::plumber_ir::FixedParamDef::default_instance();
}
inline ::plumber_ir::FixedParamDef* DFGNodeDef::mutable_fixed_param() {
  if (!has_fixed_param()) {
    clear_type_param();
    set_has_fixed_param();
    type_param_.fixed_param_ = new ::plumber_ir::FixedParamDef;
  }
  return type_param_.fixed_param_;
}
inline ::plumber_ir::FixedParamDef* DFGNodeDef::release_fixed_param() {
  if (has_fixed_param()) {
    clear_has_type_param();
    ::plumber_ir::FixedParamDef* temp = type_param_.fixed_param_;
    type_param_.fixed_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_fixed_param(::plumber_ir::FixedParamDef* fixed_param) {
  clear_type_param();
  if (fixed_param) {
    set_has_fixed_param();
    type_param_.fixed_param_ = fixed_param;
  }
}

// optional .plumber_ir.IntParamDef int_param = 202;
inline bool DFGNodeDef::has_int_param() const {
  return type_param_case() == kIntParam;
}
inline void DFGNodeDef::set_has_int_param() {
  _oneof_case_[1] = kIntParam;
}
inline void DFGNodeDef::clear_int_param() {
  if (has_int_param()) {
    delete type_param_.int_param_;
    clear_has_type_param();
  }
}
inline const ::plumber_ir::IntParamDef& DFGNodeDef::int_param() const {
  return has_int_param() ? *type_param_.int_param_
                      : ::plumber_ir::IntParamDef::default_instance();
}
inline ::plumber_ir::IntParamDef* DFGNodeDef::mutable_int_param() {
  if (!has_int_param()) {
    clear_type_param();
    set_has_int_param();
    type_param_.int_param_ = new ::plumber_ir::IntParamDef;
  }
  return type_param_.int_param_;
}
inline ::plumber_ir::IntParamDef* DFGNodeDef::release_int_param() {
  if (has_int_param()) {
    clear_has_type_param();
    ::plumber_ir::IntParamDef* temp = type_param_.int_param_;
    type_param_.int_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DFGNodeDef::set_allocated_int_param(::plumber_ir::IntParamDef* int_param) {
  clear_type_param();
  if (int_param) {
    set_has_int_param();
    type_param_.int_param_ = int_param;
  }
}

inline bool DFGNodeDef::has_op_param() {
  return op_param_case() != OP_PARAM_NOT_SET;
}
inline void DFGNodeDef::clear_has_op_param() {
  _oneof_case_[0] = OP_PARAM_NOT_SET;
}
inline bool DFGNodeDef::has_type_param() {
  return type_param_case() != TYPE_PARAM_NOT_SET;
}
inline void DFGNodeDef::clear_has_type_param() {
  _oneof_case_[1] = TYPE_PARAM_NOT_SET;
}
inline DFGNodeDef::OpParamCase DFGNodeDef::op_param_case() const {
  return DFGNodeDef::OpParamCase(_oneof_case_[0]);
}
inline DFGNodeDef::TypeParamCase DFGNodeDef::type_param_case() const {
  return DFGNodeDef::TypeParamCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// DFGDef

// required string name = 1;
inline bool DFGDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DFGDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DFGDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DFGDef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DFGDef::name() const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGDef.name)
  return *name_;
}
inline void DFGDef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:plumber_ir.DFGDef.name)
}
inline void DFGDef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:plumber_ir.DFGDef.name)
}
inline void DFGDef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:plumber_ir.DFGDef.name)
}
inline ::std::string* DFGDef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGDef.name)
  return name_;
}
inline ::std::string* DFGDef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DFGDef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:plumber_ir.DFGDef.name)
}

// repeated .plumber_ir.DFGNodeDef node = 2;
inline int DFGDef::node_size() const {
  return node_.size();
}
inline void DFGDef::clear_node() {
  node_.Clear();
}
inline const ::plumber_ir::DFGNodeDef& DFGDef::node(int index) const {
  // @@protoc_insertion_point(field_get:plumber_ir.DFGDef.node)
  return node_.Get(index);
}
inline ::plumber_ir::DFGNodeDef* DFGDef::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:plumber_ir.DFGDef.node)
  return node_.Mutable(index);
}
inline ::plumber_ir::DFGNodeDef* DFGDef::add_node() {
  // @@protoc_insertion_point(field_add:plumber_ir.DFGDef.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::plumber_ir::DFGNodeDef >&
DFGDef::node() const {
  // @@protoc_insertion_point(field_list:plumber_ir.DFGDef.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::plumber_ir::DFGNodeDef >*
DFGDef::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:plumber_ir.DFGDef.node)
  return &node_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace plumber_ir

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::plumber_ir::DFGNodeDef_Device> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::plumber_ir::DFGNodeDef_Device>() {
  return ::plumber_ir::DFGNodeDef_Device_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_plumber_5fir_2fdfg_5fdef_2eproto__INCLUDED
